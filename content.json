{"pages":[],"posts":[{"title":"關於重新導向的 status code","text":"https://zhuanlan.zhihu.com/p/60669395 https://medium.com/@dubiety/%E6%90%9E%E6%87%82-http-3xx-%E9%87%8D%E6%96%B0%E5%B0%8E%E5%90%91%E7%8B%80%E6%85%8B%E7%A2%BC-f1a288c1cd20 上面這兩篇蠻有幫助的。 想想下面這個情境。 12假設你原本的網站叫做 old.com後來你換了一個域名，叫做 new.com 再轉換初期你一定是要兩個都保持，不然原本都用 A.com 連線的小朋友們不知道你連到 B.com，他們就不知你的網站到哪裡去了。就像你的店名原本叫台南牛肉麵，突然你想要愛逮丸一點，叫做台灣牛肉麵，但其他人只知道台南牛肉麵，一直問台南牛肉麵在哪裡，殊不知你已經改名子了（好啦，如果問人一定還是知道台灣牛肉麵就是以前的台南牛肉麵）。 所以在換域名初期你會兩個域名都先保留，等大家都記住 new.com 的時候在把 old.com 關掉。但是大家都還是用 old.com 連怎麼辦？我們會把 IP 掛到 new.com，然後 old.com 用 redirect 的方式導到 new.com。 那我們要怎麼 Redirect？我們可以透過下面幾種方式 response header 的 location HTML 的 meta 元素 HTML 重新導向機制 JS 的 window.location = URL。後面兩個可能比較不熟悉，這裡不詳細講這個東西，可以看這邊 設定重新導向的其他方法 平常我們輸入 domain name 之後的流程是這樣的： client: old.com =&gt; DNS server DNS server: IP =&gt; client client: IP =&gt; server server: response =&gt; client 當我們拿到 IP 之後，為了減少之後重新向 DNS server request，所以瀏覽器有 cache 會記錄 域名 還有 IP的對，減少向 DNS request 的次數。那如果平常重新導向，會是這樣的流程 client: old.com =&gt; DNS server DNS server: IP =&gt; client client: IP =&gt; server server: response(根據 domain name) redirect to new.com =&gt; client cient : new.com =&gt; DNS server DNS server: IP =&gt; client client: IP =&gt; server 在第四個步驟 server: response(根據 domain name) 有個很重要的點，就是 Status code 這會影響到瀏覽器重新導向的方式，簡單來說重導向需要考慮的點有幾個。 永久還是臨時這個東西的影響層面跟瀏覽器還有搜尋引擎有關係。 剛剛有提到說瀏覽器會用 cache 紀錄域名還有 IP，如果是永久導向，那麼瀏覽器就會修改紀錄，例如像剛剛的流程，假如我們是永久導向。 使用者輸入 old.com 瀏覽器翻了 cache 發現這樣一筆紀錄 old.com: 3.444.555.666 了，指向到 3.444.555.666，直接向 3.444.555.666 發送 request。 reponse 顯示：永久 redirect to new.com new.com 發現 cache 裡面沒有，所以向 DNS 找找，於是找到 3.444.555.666 瀏覽器發現說這個網頁已經永久導向了，所以修改剛剛的紀錄變成 old.com: new.com, new.com: 3.444.555.666。 所以之後如果我們要搜尋 new.com 就不會再找 DNS了，而且輸入 old.com 也不會再重新發 request 到 old.com，因為已經紀錄說 old.com 已經導向到 new.com 如果是臨時導向呢？就不會有改紀錄這個動作，還是會重複原本的步驟。 要注意的是，並不一定 new.com 跟 old.com 都在同一個 server 上，也有可能在不同 server，像是短網址的服務，或者是你整個部落格也跟著搬 server 換 IP 也有可能。 而決定永久還是臨時的就是靠 status code 永久： 301, 308 臨時： 302, 303, 307 其他： 304 會被導到舊網頁 300 用戶可以自己選 好，我知道 重導向之後的 request method 還有 body還有一個問題是，如果發出的 request 不是 get 呢？例如說：你是發送表單，用的是 POST method，而且夾帶著 form data，結果 request 之後 method 變成 get，那就完全送不出資料了。 所以另外一個考量點就是，redirect 之後的 request method 還有 body。有幾種選項 GET 不變、其他 method 可能會變成 GET： 303 method 跟 body 都不會變：307, 308 為什麼沒有 301 跟 302 ？因為當初規範沒有講清楚這個東西，所以一個規範各表，變成有些有些有改、有些沒改。上面的 303, 307, 308 就是為了統一所以提出的新規範。 關於 rediredct 的 status code 大概是這樣，感謝大家收看。 使用情境可以看這邊","link":"/2020/09/21/redirect_status_code/"},{"title":"為什要用 IIFE","text":"防止污染全局變數因為 var 是 依照 function 來區分 scope(function scope) 的，所以以前都會用 IIFE 來避免汙染。但現在的 const 還有 let 都是 block scop。所以如果怕污染可以直接用大括號包起來就可以。 1234{ const a = &quot;123&quot;; let b = &quot;456&quot;} 但是，但是，就是有個但是！如果不支援 ES6 呢？所以還是用 IIFE 吧。 防止內部變數被存取這個自己還沒有用到過。可以看下面這個 case。 1234567891011const uniqueId = (function() { let count = 0; return function() { ++count; return `id_${count}`; };})();console.log(uniqueId()); // &quot;id_1&quot;console.log(uniqueId()); // &quot;id_2&quot;console.log(uniqueId()); // &quot;id_3&quot; 可以發現說，除了直接讀取 uniqueID 之外，沒有辦法存取到裡面的 count 的值。這樣就完全保證了裡面的東西不會被用到。這樣可以保證內部變數的隱私性。 JS 有一種 design pattern - revealing module pattern 很依賴這樣的模式 1234567891011121314151617181920const counter = (function() { let counterValue = 0; return { increment() { ++counterValue; }, get value() { return counterValue; } };})();counter.increment();console.log(counter.value); // 1counter.increment();counter.increment();console.log(counter.value); // 3 你只有使用 counter.increment() 才能夠操作 counter.value，而這樣的模式可以保護內部的參數。 幫 Library 新增別名。如果你用了兩個名子一樣的 library，就可以把整個 library 的東西包起來作為一個變數。 1234567window.$ = function somethingElse() { // ...};(function($) { // ...})(jQuery); 可以像這樣都包起來 然後指定給一個 variable。這種方式稱作 alias variable 給 library 一個別稱，讓同樣名子的 library 不會互相汙染，也更方便使用。 在不同的環境存取 global object：123(function(global) {// ...})(this); 如果有跨環境執行（例如一段程式碼在 browser 和 node.js 都需要執行）的狀況時，在這種情形 global object 的名稱不一樣，browser 是 window, node 是 global，那麼就可以用這種方式來統一存取 global object。 優化程式碼的名稱如果在你的 code 裡面用到很多很多全局變數的話，那你的 code 裡面會充滿著 window 或者是 global。 這時候你就可以用像剛剛 alias variable 的方式。 123(function(w, d, u) { // ...})(window, document); 這樣就可以讓 uglyfyjs 等等的 JS minifier 來縮減變數名稱。 而且這樣做還有另外一個優點，因為局部變數比全局變數處理的時間還要快。所以如果用到很多的全局變數可以這樣處理。 Local variables are faster to resolve than the global variables, but this is on a huge scale and you’ll never notice the speed increase - but also worth considering if we’re referencing our globals a lot! https://ultimatecourses.com/blog/what-function-window-document-undefined-iife-really-means 防止 undefined 的值被改變undefined 是一個 global variable，未設定的時候值是 undefined 。但 undefined 不是保留字，在沒有 strict mode 的情況下可以被 assign。所以下面的情形方式可以避免 undefined 變成奇怪的東西。 1234undefined = true;(function (window, document, undefined) { // undefined is a local undefined variable})(window, document); 參考資料 http://adripofjavascript.com/blog/drips/an-introduction-to-iffes-immediately-invoked-function-expressions.html https://ultimatecourses.com/blog/what-function-window-document-undefined-iife-really-means https://mariusschulz.com/blog/use-cases-for-javascripts-iifes https://mariusschulz.com/blog/disassembling-javascripts-iife-syntax","link":"/2020/08/23/why-iife/"}],"tags":[],"categories":[]}